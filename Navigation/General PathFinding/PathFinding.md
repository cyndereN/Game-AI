# Path Finding

https://qiao.github.io/PathFinding.js/visual/

https://zhuanlan.zhihu.com/p/656641483

## Introduction

本小结会深入浅出的分析常用的AI寻路技术，以及对比各家寻路技术方案的优劣点，然后分析目前应用最广泛的寻路技术，剖析其寻路技术的生成和寻路算法部分，以及在大世界的应用和优化等。

如何自己实现寻路？一般寻路技术的主要用法就是给定一个初始出发坐标StartPos，然后再给定一个目标结束点坐标EndPos，寻路算法主要做的就是找到从StartPos到EndPos的可达最短路径。 假如我们没有任何寻路技术背景，自己来实现寻路算法你会怎么做？那么这里就有2个关键的点需要注意，首先构成这个路径的数据是什么？也就是寻路数据是什么格式，其次采用什么算法去寻路。按照我们大学学习到的最基础的遍历算法，我们都知道深度优先遍历和广度优先遍历。我们在假设寻路数据是最简单的网格的情况下，使用广度优先算法或者朝着目标方向的深度优先算法最终都能从StartPos找到EndPos，那么我们自己实现最简单的寻路算法就实现了。

从以上的例子延伸出几个问题，如果没有特殊的优化方法，只是无脑的使用广度优先遍历或深度优先遍历，其搜索效率都不是很高，且这种情况的广度优先遍历可能会导致内存太大。另一个问题是构成我们的寻路数据的格式可能不一定是简单的网格，也许还有其他更复杂的格式比如多层网格或NavmeshPoly，不管什么格式，游戏中从地形编译生成该寻路数据都是一个较大的课题，比如需要体素化等等。寻路算法有很多种，在正式谈A*算法之前，我们先回忆一下书上学的一些最短路径算法。

## 基本定义

图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)。

其中G表示一个图，V是图G中定点的集合，E是图G中边的集合

带权的图统称为网

有很少条边的被称为稀疏图，反之称为稠密图

存储方式：
1. 邻接矩阵 （适合稠密图）
2. 邻接表：
字典的字典（字典由哈希表实现）。或是链表的数组（结点存入数组，并对及节点的孩子进行链式存储。
建立需要O(v+e)的时间复杂度

有向图中，若想通过邻接表知道有哪些顶点可以连向该顶点（入度），复杂度为O(n)。解决：4. 十字链表
无向图中，若想通过邻接表删除某条边会比较繁琐，因为要找两次。解决：5. 邻接多重表

3. 边集数组：
两个一维数组，一个存储顶点信息，一个存储边的信息。


一些算法:

1. BFS/DFS O(V+E)
    
    有向无环图（DAG）可以直接拓扑排序，再按照这个顺序DP求最短路，复杂度O(V+E)，不用到用Dijkstra

2. Dijkstra O(V^2), drops down to O(V + ElogV) with fibonacci-heap

    Dijkstra's algorithm only works on graphs with no cycles, or on graphs with a positive weight cycle.

    "带权重的BFS" 以图中的一个起始节点为基础，通过逐步扩展到其他节点来计算到每个节点的最短路径。Dijkstra算法通过不断更新节点的最短路径值，逐步扩展到其他节点，直到找到目标节点或者遍历完所有节点。它保证了在加权图中找到最短路径，但对于存在负权边的图，Dijkstra算法不适用。Dijkstra算法在路径规划、网络路由等领域广泛应用，它能够高效地找到最短路径，并且可以通过优先队列等数据结构来提高算法的效率。

3. Greedy BFS O(V+E)

    解决BFS没目的性会向反方向扩散的问题。Not good with obstacles. Picks the best node based on some rule called "heuristics". 按照离目标距离的远近排序（而不是Dijkstra的当前最短路径），所以是较优，但不总是最优。

4. bellman-ford O(VE)

    原理是对图进行V-1次松弛操作。实现简单，但复杂度过高。
    Unlike the Dijkstra algorithm, this algorithm can also be applied to graphs containing negative weight edges. However, if the graph contains a negative cycle, then, clearly, the shortest path to some vertices may not exist (due to the fact that the weight of the shortest path must be equal to minus infinity); however, this algorithm can be modified to signal the presence of a cycle of negative weight, or even deduce this cycle.

5. floyd-warshall O(V^3)
    
    是一种用于解决所有节点对最短路径的动态规划算法。它能够在有向图或带权图中找到任意两个节点之间的最短路径。Floyd算法的时间复杂度为O(n^3)，其中n是节点的数量。它适用于解决稠密图或有向图中的最短路径问题，但对于大型图可能会变得相对较慢。Floyd算法在网络路由、图论等领域有广泛的应用，它能够找到任意两个节点之间的最短路径，并且可以处理负权边的情况。然而，Floyd算法的空间复杂度较高，因为需要存储所有节点对之间的距离信息。

6. SPFA（Shortest Path Faster Algorithm）

    是一种用于解决单源最短路径问题的算法，它是对Bellman-Ford算法的一种优化，SPFA算法的优化在于使用了队列来选择下一个要处理的节点，而不是像Bellman-Ford算法那样遍历所有节点。这样可以减少不必要的重复计算，提高算法的效率。SPFA算法适用于解决带有负权边的图中的最短路径问题，但对于存在负权环的图，SPFA算法会进入无限循环。因此，在使用SPFA算法时，需要注意检测负权环的存在。SPFA算法在网络路由、图论等领域有广泛的应用，它能够高效地找到单源最短路径，并且可以处理负权边的情况。

7. Theta（Theta Star）
    是一种对A算法的一种改进和优化。Theta算法在A算法的基础上引入了"theta"角度的概念，用于判断两个相邻节点之间是否可以直接连线，而不需要沿着网格或图的边缘行走。这样可以减少路径的节点数，提高路径规划的效率。接下来介绍常用的寻路算法A*

8. 避障算法（以后填坑）
    https://indienova.com/indie-game-development/vo-rvo-orca/

## A*算法

扩展+择优

提到寻路算法，一般讲的最多的就是A*算法，A*算法在路径规划、游戏AI等领域广泛应用，它能够高效地找到最短路径，并且可以通过调整启发式估计函数的权重来平衡搜索速度和最优解的质量。它结合了广度优先搜索和贪婪最优搜索的特点，通过评估每个节点的启发式估计值来选择下一个要探索的节点。A*算法以及其延伸的寻路优化算法是寻路中应用最广泛的。A*算法把搜索拆分为了H值和G值，搜索优先值F=H+G，G值（耗费值）：指从起点走到该点要耗费的值。H值（预测值）：指从该点走到终点的预测的值(不考虑阻挡的直线距离),复杂的会考虑使用启发函数来计算该值。搜索的过程也是遍历网格，根据规则引入了openlist和endlist去辅助搜索。A*算法一般情况下效率是比较高的，但是网格数量太大以后遍历顶点还是很多，因此有人提出了一些优化改建思路Jps算法和Jps+，其都有不俗的性能表现。

A*一般是基于BFS，是一种基于静态网格的寻路算法。

优化：

- Openlist 选择二叉树，优先队列，斐波那契堆等优化直接取得最小值
- Clostlist 用Tmap 替代二维表判断
- 引入深度限制
- 每个格子不要存储坐标内存，用boundingbox然后根据下标索引

## JPS

JPS（jump point search）跳点算法实际上是对A* 寻路算法的一个改进，是基于深度优先搜索DFS。JPS和A*的主要区别就是引入了跳点的判断，对于每个邻居节点，检查是否存在跳点（Jump Point），如果存在跳点，则将跳点添加到开放列表，并计算它的启发式估计值。如果不存在跳点，则将邻居节点添加到开放列表，并计算它的启发式估计值，通过该种方式，即可以直接跳过一些节点到达目标节点的路径。JPS算法通过跳点扩展的方式，减少了搜索空间，避免了对不必要的节点进行扩展，从而提高了路径规划的效率。

强迫邻居：当节点X的八个邻居中存在障碍，且节点X的父节点P，经过节点X到达节点N的距离代价，总是小于不经过节点X到达节点N的任意路径的距离代价，则称节点N是节点X的强迫邻居

分为两种情况，父子节点在一条直线或者在斜线上。

跳点：满足以下三个条件之一即可成为跳点

1. 节点X是起点或者终点
2. 节点X至少有一个强迫邻居
3. 节点X的父节点p在斜线方向，并且节点X的直线方向存在满足1or2的节点

**JPS+**

O(n)预处理，最主要就是把跳点的选择进行预处理，不需要运行的时候去判断跳点，离线烘焙好，运行的时候直接使用，那么性能肯定会更好。因此整体性能来说JPS+ > JPS >A*，但是JPS+上预烘焙跳点数据，因此无法支持动态地图，内存更多一些，且一般只能在网格中使用。

**JPS算法常用的优化手段**

常见的优化手段有很多种，比如JPS-Bit和JPS-BitPrune，通过引入位图（BitMap）通过使用位图数据结构进行剪枝，避免对已经访问过的节点进行重复扩展，从而减少搜索空间，提高路径规划的效率。

剪枝是最常用的优化手段之一，一种常见的方法是使用启发式函数来估计从当前节点到目标节点的距离，并根据该估计值确定一个边界或区域，只在该区域内进行搜索。这样可以排除掉远离最佳路径的区域，集中搜索在可能更接近最佳路径的区域内。简单来说就是目标点在右边为就尽可能把左边的节点剪掉，只去搜索右方向节点。

另外还有其他的优化思路，比如路径拼接，这在大世界超远距离是很好的优化手段，可以分段寻路。双向搜索（Bidirectional Search）是对内存和性能很好的一种优化手段，从下图可看出双向搜索在某些情况比单项搜索节点会少很多。以及路点平滑和分帧运算等等。

*可能比 A\* 更慢的情况*

- 地图规模很小或障碍物密集：

    跳点搜索的“跳”经常被障碍物打断，导致 JPS 不得不频繁回退，失去优化效果。

    此时 JPS 的额外逻辑开销（检测强制邻居、递归跳点搜索）反而让它比 A* 慢。

- 如果不是4/8 邻接方格，JPS 的加速机制就会出问题。

## 其他寻路算法（群体寻路）

**FlowField**

FlowField 流场寻路算法适合群体的流体场寻路，每个格子记录目标点的方向，每次更新目标点需要重新计算流体场。重新计算过程消耗较大毫秒级别。一般适合小型地图但是海量AI需要寻路的场景。

通过BFS，记录热力图，变成向量场，双线性插值。

问题在于，转弯效果，单位间碰撞，单位障碍碰撞。

通过Steering Behaviour解决

**Steering Behaviour转向行为**

核心思想是通过力驱动单位运动。给每个Agent的movement capsule施加力

- Seek靠近行为，通过转向力改变单位速度方向

- Separation分离行为，在单位碰撞范围内进入其他单位时，增加一个和单位之间距离成反比的斥力

- Avoidance避障行为。对于矩形障碍单位会向前方发射三条定长射线（圆形则只有一条，类似RVO)，如果相交则施加一个法线方向的斥力。如果有多个交点，只保留最近。同时根据点乘计算补充动力。


**Hierarchical and Dynamic Pathfinding动态层级寻路**

层级寻路采用类似四叉树的结构，将寻路数据分为了三层，远距离的时候采用上层较粗数据进行搜索查询，上层路径打通以后，再下层到更精细的层级进行寻路，最终由多层数据构成了完整的寻路数据。寻路的时候首先根据起始点和结束点查询该点所在的数据层，先查询最粗粒度的外层，然后使用A*将外层最短路径链接起来，获得初步寻路数据。然后再根据外层数据查询开始点和结束点所在的精细内层数据，然后再链接精细数据到粗粒度外层数据的路径。那么完整的起始点到终点的层级寻路数据链就构建出来了。

Hierarchy层级寻路由于可以通过层次块的方式去压缩内存和不同粗粒度去完成搜索算法，因此总体内存表现是很不错的，比Navmesh内存少数倍，唯一的缺陷是有太多流程和优化算法需要项目中本身投入大量精力去研究，缺少完整可用的工具链支持。

层级寻路采用类似四叉树的结构，将寻路数据分为了三层，远距离的时候采用上层较粗数据进行搜索查询，上层路径打通以后，再下层到更精细的层级进行寻路，最终由多层数据构成了完整的寻路数据。寻路的时候首先根据起始点和结束点查询该点所在的数据层，先查询最粗粒度的外层，然后使用A*将外层最短路径链接起来，获得初步寻路数据。然后再根据外层数据查询开始点和结束点所在的精细内层数据，然后再链接精细数据到粗粒度外层数据的路径。那么完整的起始点到终点的层级寻路数据链就构建出来了。

**体素寻路**

在Navmesh的生成过程中，首先就需要对场景数据进行体素化存储，大世界体素化如果是以1m一个格子，那么10*10km的场景就是100000000*H个格子，内存容量相当的大，每个格子不仅要存储是否有碰撞可能还需要存储一些其他的玩法属性。如果采用常规的存储方式或者传统的八叉树存储其内存和性能在真机上可能都是无法容忍的。所以一般情况下体素化方案用于场景较小的游戏比如100•100m这样的小场景，但是对物理计算要求特别高的情况下，可以使用体素化做到O(1)查询，提高效率。有一些关卡游戏目前就是使用的该方案。但是国内也有MMO游戏使用体素的，最成功的案例应该就是天刀了，他们客户端和服务器都是使用了体素，物理和Navmesh都是通过体素计算。这是源自于他们对体素化数据进行了极致的压缩化存储。他们将一些特殊结构的组合层（比如中空情况）进行合并，同时要对体素数据进行分层和Streaming，近处的数据上全量体素信息，远处Cell的数据只需要存储粗略数据或者精读更低的数据，同时结合分层寻路算法进行寻路。同时数据结构上采用最精简的存储方式，比如使用Tmap存储带高度压缩信息的体素块，将维度从3维降低到2维。以1km•1km为例，0.5•0.5为体素大小，假如每个2维体素使用极度压缩组合后的数据只占4字节，那么总内存大小在15-30M范围内数可以接受的。当然考虑到超大世界10km肯定就只能使用Streaming分块加载了。

**大世界路点寻路**

Navmesh一般可以解决短距离寻路，但是在大世界超远距离寻路下Navmesh还是吃不消的，不管是内存还是性能都吃不消，因此才孕育而生了各种层级寻路算法，但这种方法并不是最优选择，大世界Navmesh寻路的优化有很多种方法，今天暂时只讲一种，UBI在刺客信条-起源中使用到的大世界路点寻路，在超大世界里边使用了路点进行寻路，由于路点是稀疏型，内存和性能肯定都会小很多，在超大世界中首先使用路点进行寻路，路点寻完以后下层精细化路径再使用Navmesh寻路，这本身也是一种层级化寻路思维。但是在超大世界地图上即使使用路点寻路，数据量仍然达到了惊人的数百万。因此其数据结构如何整理以及如何使用压缩型数据结构既保证内存较小又保证性能可控是一个不小的挑战。不过本篇文章不打算继续展开了，本章聚焦在寻路引擎Recast Navmesh的分析。Navmesh相关的大世界优化，以及如何大世界如何使用路点，大世界如何生成数十万的Link线将在大世界专栏再单独介绍。

## 和NavMesh的区别

1. 单纯的A*算法性能内存都一般，JPS比Navmesh稍慢，内存JPS稍高，但是在预处理后JPS+时间效率就比Nav更快，预处理要多存储八个方向的可达距离带来的内存消耗大，JPS在动态阻挡上效率更高,但是预处理后就不支持动态阻挡了。

2. 采用的动态层级寻路HDP比Navmesh有更低的内存消耗, 数倍之差，单次完整寻路时间比不上Nav，但是层级分多次寻路启动时间比Nav更快。不过主要弊端是全部流程基本需求自己开发，而且就算开发出该算法流程以后，其相关的配套优化算法（比如路径优化,动态加载和动态链接）也需要自己开发，容易跟不上项目进展，总体上高成本方案。

3. recast navmesh在内存和CPU消耗都相对较好，且工具链完善，寻路算法优化成熟，是一般项目的首选。


